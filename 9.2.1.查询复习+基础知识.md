## 关系模型：

   所有的关系型的数据库都是基于关系模型：
   是由行和列组成的一种二维表格。
   元组：代表关系模型中的一行数据。
   属性：二维表格中的每一个列就叫做一个属性，会给每一列属性起一个名称，叫做属性名。
   域：关系模型中每一个属性的取值范围就叫做属性域。

###    关系模型特点：

#####     1.原子性：关系模型中的属性具有原子性，不能再拆分。

##### 	2.关系模型中要求不能有重复的元组，也就是不能有重复的行。

##### 	3.理论上关系模型中的元组是没有行序，但是在实际使用的过程中可以指定行序。

### 关键码：

  超键：在关系模式中，能唯一标识元组的属性集称为超键。
  候选键：如果一个属性集能唯一标识元组，且有不包含多余属性，那么这个属性集称为候选键；也即：候选键是没有多余属性的超键。
  主键：关系模式中用户正在使用的候选键称主键(primary key)
  外键：在关系模式R中，如果某属性集是其他模式的候选键，那么该属性集对模式R来说就是外键

```sql
id  name   age   sex   pwd
1   小明   18    男    123456
2   小白   19    女    123456

姓名唯一，是个超键
学号唯一，是个超键
（姓名，年龄）唯一 ，是个超键
（学号，努力）唯一，是个超键
姓名唯一，且没有其他多余属性，是个候选键
学号唯一，且没有其他多余属性，是个候选键
考虑方便查询，我们使用学号作为主键；也可以根据习惯，使用姓名作为主键；即选中的候选键就是主键
```

##    三范式：

####     第一范式：关系模型中的每一个属性不能再分，如果属性可以再分就代表违反了第一范式

#### 	第二范式：关系模型中的每一个属性都必须要直接依赖主键，不能有传递依赖。

#### 	第三范式：每个非关键字列都独立于其他非关键字列，并依赖于关键字，将不直接依赖的属性重新创建一张表，通过外键和当前表进行关联

```
   id  name   age   sex   address
	1   小明   18    男    广东省深圳市龙岗区
	2   小白   19    女    广东省深圳市龙岗区
	
```



	id  name   age   sex  地址编号  pro     city     qu
	1   小明   18    男      01     广东省 深圳市  龙岗区
	2   小白   19    女      01     广东省 深圳市  龙岗区
	
	id  name   age   sex  
	1   小明   18    男        
	2   小白   19    女          
	
	地址编号  pro     city     qu        pid
	    01     广东省 深圳市  龙岗区      1
		02     广东省 深圳市  福田区      1



### 关系模型设计：

#####   逻辑模型设计图形：E-R图。

#####   三要素：

######   实体：实际生活中客观存在的一些事物，例如：学生，老师，等等

​      实体使用矩形表示。

######   属性：属性就是实体的特征。

​      属性主要使用椭圆表示

######   联系：代表实体和实体之间的关系，联系使用菱形表示。

​     

#### 一对一：

实体集A中的每一个实体在实体集B中只有唯一的一个实体与之对应，反之亦然。

```sql
例如：人和身份证的关系
		设计表的时候：1.方式一：在两张表中互存外键
		
		person                        card
		pid      PK                    cid          PK
		name                           cardno
		cid     FK                      pid   FK
		
2.方式二：两张表共用一个主键，pid和cid要保持一致
					   
			person                        card
		pid      PK                    cid          PK
		name                           cardno
```

#### 一对多|多对一：

实体集A中每一个实体在实体集B中有多个实体与之对应，实体集B中的每一个实体
在实体集A中只有一个与之对应。

```
例如;菜系和菜品
			
设计表规则：在多的一方保存一的一方的主键作为外键
   人员表（一方）
	id  name   age   sex  
	1   小明   18    男        
	2   小白   19    女          
	地址表(多方)
	地址编号  pro     city     qu        pid
	    01     广东省 深圳市  龙岗区      1
		02     广东省 深圳市  福田区      1
```



#### 多对多：

实体集A中的每一个实体在实体集B中有多个实体与之对应，反之亦然。


​				

	例如：学生和课程。
	表设计规则：需要创建一张中间表来关联两个实体，中间表中保存两个实体的主键，中间表的主键是由两个实体的主键组成的一个复合主键。	 
			
			student:         score(中间表)  course:
			  sid             sid           cid
			  name            cid           name
			                  score


​	

###### 逻辑模型：主要就是在设计阶段绘制E-R图来进行设置，代表的是一种逻辑关系。

###### 物理模型：代表具体创建出来的数据库表，是将逻辑模型要转换成物理模型，然后进行建表。

​	
​	

# sql语言的分类：

####    1.DQL:数据查询语言：是数据库中使用最频繁的语言主要关键字：select

####    2.DML:数据操纵语言：主要是用来改变数据库对象中的数据的一种语言，主要关键字：insert   update   delete

####    3.DDL:数据定义语言：主要就是针对数据库对象的创建，修改和删除操作：create    alter   drop   truncate

####    4:TCL:事务控制语言：主要就是正对数据库中的事务操作的语句：commit    rollback  savepoint

######                        事务特性：原子性，一致性，隔离性，持久性

####    5:DCL: 数据控制语言：主要是正对权限进行操作：grant    revoke  



# SQL查询：

```sql
    语法：select  [distinct|all] 列名，..|* 
	      [into 变量]
		  from 表名|视图名
		  [where 过滤条件]
		  [group by 分组字段,...]
		  [having 分组过滤]
		  [order by 排序字段 [desc|asc],....]
```



    sql语句的执行顺序：
      from-----where-----group by----having-----select----order by 

#### 单表查询：

#### 多表关联查询：

 1.普通关联：select * from A,B where 关联条件;

 2.内连接： select * from A [inner] join B on 关联字段

 3.外连接：left [outer] join ...on
           right [outer] join ...on
		   full [outer] join ...on




```
有两张表A和表B,其中表A有16条数据，表B有9条数据，表A中有15条数据和表B相关联，表B中有4条数据和表A相关
请问：A 内连接B有几条数据？   15    (取关联数据多的表的关联条数)
      A 左连接B有几条数据？   16    （内连接结果+左表不相关的条数）
	  A 右连接B有几条数据？   20    （内连接结果+右表不相关的条数）
	  A 全连接B有几条数据？   21     （内连接结果+右表不相关的条数+左表不相关的条数）
```

 4.自然连接： natural join 

 5.自连接：自己连接自己
    一般会有一个自引式外键：表中有一个字段的值引用自己表的主键作为外键。

```sql
--查询员工表中员工的姓名以及领导的姓名。
SELECT e1.ename 员工,e2.ename 领导 FROM emp e1,emp e2 WHERE e2.empno=e1.mgr;	
```

6.交叉连接:  cross join



### 子查询：

######  1.单行子查询：子查询的结果返回一行数据

​               配合运算符：> < >= <= <> =
​    		   

```sql
--查询工资最高的员工的编号，姓名，职位和工资
SELECT max(sal) FROM emp;
SELECT empno,ename,job,sal FROM emp WHERE sal=(SELECT max(sal) FROM emp);
```



###### 2.多行子查询：子查询的结果返回多行数据

​               运算符：in   any   all
​    		          in 等同于 =any
​    				  not in 等同于  <>all  
​    				  注意：一般没有=all  或者是<>any的写法。

###### 3.关联子查询：子查询的执行必须要依赖于外查询的条件字段，不能单独执行。

​              [not] exists:用来判断子查询结果是否在外查询中存在
​    		  语法：select * from 表 a where [not] exists(select * from 表B where 关联字段=a.关联字段) 	

注意：1.如果子查询数据量比较小，推荐使用in
              2.如果子查询的数据量比较大，推荐使用exists.



### 常用的函数：

##### 1.字符串函数：

##### 2.算术类函数：

##### 3.转换函数：

##### 4.时间函数：

##### 	sysdate:获取系统当前的时间对象

##### 	last_day():获取指定日期对应的月的最后一天

##### 	add_months(d,n):在指定的日期上加上或者减去n个月

```sql
--十天前
SELECT SYSDATE-10 FROM dual;
--一分钟之后
SELECT SYSDATE+1/24/60 FROM dual;
```



##### months_between(d1,d2):

查询两个之间之间相差的月份数，是一个小数

```sql
SELECT hiredate 入职日期,round(months_between(SYSDATE,hiredate)/12) FROM emp;
```



##### trunc(d,'参数'):(重要)

可以将时间截断到指定的参数的开始位置。

```sql
SELECT SYSDATE,TRUNC(SYSDATE)天,TRUNC(SYSDATE,'mm')月,TRUNC(SYSDATE,'q')季度,TRUNC(SYSDATE,'yy')年,
		trunc(SYSDATE,'day')本周第一天星期天,TRUNC(SYSDATE,'iw')本周星期一,TRUNC(SYSDATE,'ww')上周六 FROM dual;
```

   

##### extract(year|month|day|hour|... from 时间对象|时间戳对象):

截取具体的一个年，或者月或者天。。。。。；	



######   注意：如果要截取年月日，则直接从date类型截取

######          		如果要截取时分秒，则需要从timestamp类型截取。

##### 5.分支类的函数：

######    1.case ..when

​     语法一：case 字段 when 值1 then  语句1
​	                   when 值2 then  语句2
​					   ......
​					   else   语句n
​					   end
​		执行顺序：如果字段的值等于值1则执行语句1，否则如果等于值2则执行语句2....如果都不相等则执行语句n

​        注意：该种方式只能进行等值匹配

​      语法二：case when 条件1 then 语句1
​						条件2 then 语句2
​						。。。。
​						else  语句n
​						end
​		执行顺序：如果条件1成立，则执行语句1，否则如果条件2成立，则执行语句2,.....如果都不成立则执行语句n;



###### 2.nvl(字段,值):如果字段的值为null则返回值，否则返回字段的值。

​	     

```sql
SELECT e.*,NVL(comm,100) FROM emp e; 
      nvl2(字段,值1,值2):如果字段的值不为空则返回值1，否则返回值2.	
      
--如果原来有奖金则增加100，如果原来没有奖金则设置200.
SELECT e.*,NVL2(comm,comm+100,200) FROM emp e;
```



###### 3.decode():	只能做等值匹配

​        语法一：decode(字段,值1,值2,值3)：如果字段的值等于值1则返回值2，否则返回值3.
​				

```sql
SELECT e.*,DECODE(comm,NULL,200,comm+100) FROM emp e;
```

​		语法二：decode(字段,值1,语句1,值2,语句2,.......,语句n):
​		        如果字段的值等于值1则返回语句1，否则如果等于值2则返回语句2,......如果都不匹配则返回语句n
​				

```sql
SELECT e.*,DECODE(job,'CLERK','办事人员','SALESMAN','销售人员','MANAGER','管理人员','无名小卒') FROM emp e;
```



##### 6.表集合操作：

######     1.并集操作：union [all]

  	  将两个结果集进行上下合并在一起。
	  select 语句1
	  union [all]
	  select 语句2
	  union [all]
	  ......
	  注意：1.合并的结果集必须要具有相同的列数。
	        2.如果设置了all关键字则不会去重，直接将两个结果集合并到一起，如果不写all会进行去重。

###### 	2.交集操作：intersect

​       返回两个结果集中相同的数据
​        select 语句1
​	  intersect
​	  select 语句2
​	  intersect
​	  ......
​	  注意：1.结果集必须要具有相同的列数。

######     3.差集操作：minus

​       返回前面表减去后面表中相同的数据之后的数据。		
​	    select 语句1
​	  minus
​	  select 语句2
​	  minus
​	  ......
​	  注意：1.结果集必须要具有相同的列数。